#!/usr/bin/env python3
"""
reader_normalVsTumor.py
Description:
    Processes DeepBase v3.0 metafile_NNNN.sampleID.csv files containing
    lncRNA (ENSG) expression values. For each cancer type, it generates:

        (1) A per-cancer file:
              [ENSGID]-output_[CANCER].csv

            Columns:
                tissue       (normal or cancer)
                barcode      (TCGA ID)
                fpkm         (expression value)

        (2) A summary statistics file:
              [ENSGID].csv

            Columns:
                cancer_type
                normal-mean
                cancer-mean
                n_normal
                n_cancer
                p-value
                significance_level

    Expression values are parsed per TCGA barcode, and samples are classified
    into normal vs cancer according to TCGA sample type codes.

EXPECTED INPUT FORMAT:
    metafile_NNNN.sampleID.csv   (generated by DeepBase v3.0)

    Row structure:
        col0 = Gene identifier (ENSG)
        col1… = expression values in FPKM for each TCGA barcode

    Header row (row 1) consists of TCGA barcodes.

SAMPLE USAGE:
    python3 reader.py -i ENSG00000226496.2
"""

import os
import csv
import argparse
from pathlib import Path

import numpy as np
from scipy import stats


def parse_args() -> argparse.Namespace:
    """Parse user-provided arguments: ENSG ID and directory."""
    parser = argparse.ArgumentParser(
        description="Summarize lncRNA expression (normal vs cancer) from Deepbase metafiles."
    )
    parser.add_argument(
        "-i",
        "--ensg",
        required=True,
        help="ENSG accession number of the lncRNA (e.g. ENSG00000226496.2)",
    )
    parser.add_argument(
        "-d",
        "--directory",
        default="/Users/darmirador/Desktop/Python Scripts/normalVsCancer_lncRNA",
        help="Directory containing metafile_*.csv files (default: previous working directory).",
    )
    return parser.parse_args()


def get_metafiles(path: Path):
    """Return sorted list of metafile_*.csv files in directory."""
    return sorted(
        f for f in path.iterdir()
        if f.is_file() and f.name.startswith("metafile") and f.suffix == ".csv"
    )


def cancer_type_from_filename(fname: Path) -> str:
    """
    Extract cancer type from metafile name.
    Expected format: metafile_NNNN.sampleID.csv → NNNN
    """
    parts = fname.name.split("_")
    if len(parts) < 2:
        return "UNKNOWN"
    return parts[1].split(".")[0]


def significance_from_p(p_value: float) -> str:
    """Return star code for p-value thresholds."""
    if np.isnan(p_value):
        return "n/a"
    if p_value < 0.0001:
        return "****"
    elif p_value < 0.001:
        return "***"
    elif p_value < 0.01:
        return "**"
    elif p_value < 0.05:
        return "*"
    else:
        return "ns"


def process_file(
    csv_path: Path,
    accession_number: str,
    cancer_type: str,
    out_dir: Path,
    summary_writer: csv.writer,
):
    """
    Process one metafile:
        - Identify TCGA barcodes (header row)
        - Locate expression row for the ENSG of interest
        - Extract expression values
        - Classify samples into normal vs cancer using TCGA sample-type code
        - Write per-cancer output file
        - Compute summary statistics (means, n, p-value)
        - Append statistics to summary file
    """

    # ------------------------
    # Read file + find ENSG row
    # ------------------------
    with csv_path.open("r", newline="") as fh:
        reader = csv.reader(fh)
        header = next(reader)      # first row contains TCGA barcodes
        tcga_ids = header[1:]      # exclude gene name column

        expression_row = None
        for row in reader:
            if row and row[0] == accession_number:
                expression_row = row[1:]  # keep only expression values
                break

    if expression_row is None:
        print(f"[WARN] {accession_number} not found in {csv_path.name}; skipping.")
        return

    # ------------------------
    # Sanity checks
    # ------------------------
    if len(expression_row) != len(tcga_ids):
        print(
            f"[WARN] Length mismatch in {csv_path.name}; "
            f"{len(tcga_ids)} TCGA IDs vs {len(expression_row)} values."
        )
        return

    # ------------------------
    # Classify samples
    # ------------------------
    normal_ids, normal_vals = [], []
    cancer_ids, cancer_vals = [], []

    for barcode, expr in zip(tcga_ids, expression_row):

        if expr == "" or expr is None:
            continue

        value = float(expr)

        # TCGA barcode format: TCGA-XX-YYYY-SSS...
        # The sample-type code is the first two digits of the 4th field.
        parts = barcode.split("-")
        if len(parts) < 4:
            continue

        sample_type_code = parts[3][:2]

        # 01, 02 → primary / recurrent tumor
        # 11      → normal
        if sample_type_code in {"01", "02"}:
            cancer_ids.append(barcode)
            cancer_vals.append(value)
        elif sample_type_code == "11":
            normal_ids.append(barcode)
            normal_vals.append(value)

    # ------------------------
    # Write per-cancer output file
    # ------------------------
    output_filename = f"{accession_number}-output_{cancer_type}.csv"
    output_path = out_dir / output_filename

    with output_path.open("w", newline="") as out_fh:
        writer = csv.writer(out_fh)
        writer.writerow(["tissue", "barcode", "fpkm"])
        for b, v in zip(normal_ids, normal_vals):
            writer.writerow(["normal", b, v])
        for b, v in zip(cancer_ids, cancer_vals):
            writer.writerow(["cancer", b, v])

    # ------------------------
    # Compute summary statistics
    # ------------------------
    normal_vals = np.array(normal_vals, dtype=float)
    cancer_vals = np.array(cancer_vals, dtype=float)

    n_normal = len(normal_vals)
    n_cancer = len(cancer_vals)

    if n_normal > 1 and n_cancer > 1:
        p_value = stats.ttest_ind(normal_vals, cancer_vals).pvalue
    else:
        p_value = float("nan")

    normal_mean = float(np.mean(normal_vals)) if n_normal > 0 else float("nan")
    cancer_mean = float(np.mean(cancer_vals)) if n_cancer > 0 else float("nan")
    significance = significance_from_p(p_value)

    # ------------------------
    # Append to summary CSV
    # ------------------------
    summary_writer.writerow(
        [
            cancer_type,
            normal_mean,
            cancer_mean,
            n_normal,
            n_cancer,
            p_value,
            significance,
        ]
    )

    print(f"Done processing {csv_path.name} → saved {output_filename}")


def main():
    args = parse_args()
    accession_number = args.ensg
    base_dir = Path(args.directory).expanduser().resolve()

    print(f"[INFO] Processing metafiles for {accession_number} in {base_dir}")

    meta_files = get_metafiles(base_dir)
    if not meta_files:
        print(f"[ERROR] No metafile_*.csv files found in {base_dir}")
        return

    # ------------------------
    # Initialize summary file
    # ------------------------
    summary_path = base_dir / f"{accession_number}.csv"
    with summary_path.open("w", newline="") as summary_fh:
        summary_writer = csv.writer(summary_fh)
        summary_writer.writerow(
            [
                "cancer_type",
                "normal-mean",
                "cancer-mean",
                "n_normal",
                "n_cancer",
                "p-value",
                "significance_level",
            ]
        )

        # Process each metafile
        for csv_path in meta_files:
            cancer_type = cancer_type_from_filename(csv_path)
            process_file(
                csv_path,
                accession_number=accession_number,
                cancer_type=cancer_type,
                out_dir=base_dir,
                summary_writer=summary_writer,
            )

    print(f"[INFO] Finished generating summary file: {summary_path.name}")


if __name__ == "__main__":
    main()
